#!/usr/bin/env Rscript
# vim: ft=r

options(warn=-1)

# Sensor 1 is usually the oven
# Sensor 2 is usually the meat

warningMessage <- function(message) {
  prefix <- 'error:'
  write(paste(prefix, message), stderr())
}

fetchSensorData <- function(time_now, con, sensor_number) {
  epoch_max <- as.integer(time_now)
  epoch_min <- epoch_max - 86400
  table <- paste("sensor_", sensor_number, sep="")
  where <- paste("epoch >=", epoch_min)
  where <- paste(where, "AND epoch <=", epoch_max)
  where <- paste(where, "AND mC > -300000")
  sql <- paste("SELECT epoch, mC FROM", table, "WHERE", where)

  res <- dbSendQuery(con, sql)
  data <- fetch(res, n=-1)
  dbClearResult(res)
  return(data)
}

convertRawData <- function(raw_data, start_epoch) {
  return(data.frame(
    time=raw_data$epoch - start_epoch,
    temperature=raw_data$mC / 1000.0
  ))
}

fetchAllData <- function(time_now, sqlite_path) {
  con <- dbConnect(SQLite(), sqlite_path)
  raw_data_1 <- fetchSensorData(time_now, con, 1)
  raw_data_2 <- fetchSensorData(time_now, con, 2)
  dbDisconnect(con)

  start_epoch <- min(
    min(raw_data_1$epoch),
    min(raw_data_2$epoch)
  )

  data_1 <- convertRawData(raw_data_1, start_epoch)
  data_2 <- convertRawData(raw_data_2, start_epoch)

  return(list(
    start_epoch=start_epoch,
    sensors=list(data_1, data_2)
  ))
}

modelRecent <- function(time_now, data, window_size, sensor_number) {
  epoch_now <- as.integer(time_now)
  time_now <- epoch_now - data$start_epoch
  t0 <- time_now - window_size
  recent <- data$sensors[[sensor_number]]
  recent <- recent[recent$time > t0,]  # Should check time < now as well?
  if (nrow(recent) < 3) {
    return(NULL)
  }
  model <- lm(recent$temperature ~ recent$time)
  return(model)
}

doneTime <- function(meat_model, done_temperature) {
  # Done time
  # meat-model:
  #    temperature = r(time) + i
  # => done-time = (done-temperature - i) / r
  i <- meat_model$coefficients[[1]]
  r <- meat_model$coefficients[[2]]
  return((done_temperature - i) / r)
}

meatGuidelines <- function(start_epoch, meat_model, done_temperature) {
  # Temperature
  abline(done_temperature, 0, lty=3, col=8)
  label <- paste(done_temperature, "\u00B0C", sep="")
  text(0, done_temperature, label, pos=3, col=1)

  # Done time vertical
  done_time <- doneTime(meat_model, done_temperature)
  abline(v=done_time, lt=3, col=8)

  # Done time label
  start_time <- as.POSIXct(start_epoch + done_time, origin="1970-01-01")
  label <- strftime(start_time, '%H:%M')
  text(done_time, done_temperature, label, pos=2, col=1)

  # Done time marker
  points(done_time, done_temperature, type="p", lwd=4, col="cyan")
}

fetchAndPlot <- function(
  time_now,
  sqlite_path,
  png_path,
  png_dimensions,
  done_temperatures
) {
  data <- fetchAllData(time_now, sqlite_path)

  s1 <- data$sensors[[1]]
  s2 <- data$sensors[[2]]

  # TODO get better names for "time_now" and "cook_time"
  cook_time_now <- as.integer(time_now) - data$start_epoch

  if (nrow(s1) == 0 && nrow(s2) == 0) {
    warningMessage(paste(
      "no data found in the 24 hours before",
      strftime(time_now, '%Y-%m-%d %H:%M:%S')
    ))
    return(FALSE)
  }

  # Predictions, required to get the size of the graph correct
  small_window_size <- 300
  oven_model <- modelRecent(time_now, data, small_window_size, 1)
  meat_model <- modelRecent(time_now, data, small_window_size, 2)

  # done-times, needed to get scale right
  done_times <- numeric(0)
  if (!is.null(meat_model)) {
    for (t in done_temperatures) {
      done_times <- c(done_times, doneTime(meat_model, t))
    }
    # TODO ignore done_times in the past
    # TODO ignore done_times ridiculously far into the future (>12 hours?)
    done_times <- done_times[done_times > 0]
  }

  ## BEGIN PLOT
  # TODO parse these from the output of fbset(8) ?
  png(png_path, width=1920, height=1080, units="px")

  par(
    cex=3.0,
    family="mono"
  )

  # Current stats, for the subtitle
  clock <- strftime(time_now, "%H:%M")
  subtitle <- paste('time=', clock, sep="")

  # Plot the basic lines
  plot(
    s1$temperature ~ s1$time,
    type="l",
    xlim=range(c(done_times, s1$time, s2$time)),
    ylim=range(c(-10, 100, s1$temperature, s2$temperature)),
    lwd=4,
    main="Tempnalysis",
    sub=subtitle,
    xlab="Cook Time / s",
    ylab="Temperatue / \u00B0C"
  )

  points(
    s2$temperature ~ s2$time,
    type="l",
    lwd=4,
  )

  # Draw on models
  if (!is.null(oven_model)) {
    abline(oven_model, lt=2, col=4)
  }

  if (!is.null(meat_model)) {
    abline(meat_model, lt=2, col=4)

    # Meat guidelines
    for (t in done_temperatures) {
      meatGuidelines(data$start_epoch, meat_model, t)
    }
  }

  graphics.off() # quieter version of dev.off()
  return(TRUE)
}

library("methods")
library("optparse")

# Command line options
parser <- OptionParser(option_list = list(
  make_option(
    "--time",
    type="character",
    default=as.POSIXct(Sys.time()),
    help="Plot the graph at this time, default is current time"
  ),

  make_option(
    "--sqlite-path",
    type="character",
    default="/var/lib/bluethermd/sqlite",
    help="Path to bluethermd's sqlite database",
  ),

  make_option(
    "--done-temperatures",
    type="character",
    default="55,65,75,85",
    help="Comma separated list of temperatures to aim for"
  ),

  make_option(
    "--output",
    type="character",
    default="plot.png",
    dest="png_path",
    help="Output path for generated PNG"
  ),

  make_option("--width",  type="integer", default="1000", help="PNG width"),
  make_option("--height", type="integer", default="1000", help="PNG height")
))

options <- parse_args(parser)

png_dimensions <- c(options$width, options$height)
done_temperatures <- as.numeric(strsplit(options$`done-temperatures`, ',')[[1]])
time_now <- as.POSIXct(options$time, origin="1970-01-01")

library("DBI")
library("RSQLite")

is_complete <- fetchAndPlot(
  as.POSIXct(options$time, origin="1970-01-01"),
  options$`sqlite-path`,
  options$png_path,
  png_dimensions,
  done_temperatures
)

if (is_complete) {
  exit_status <- 0
} else {
  exit_status <- 2
}

quit(status = exit_status)
