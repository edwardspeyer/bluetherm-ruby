#!/usr/bin/env python3
"""

= OS X:

  brew install python3 hg sdl sdl_image sdl_mixer sdl_ttf portmidi
  pip3 install hg+http://bitbucket.org/pygame/pygame
  pip3 install pillow

= Debian 8:

There is no python3-pygame package, but we can build our own.  I used this
pygame:

    http://www.pygame.org/ftp/pygame-1.9.1release.tar.gz

I needed these dependencies:

    $ sudo apt-get install python3-dev libsdl1.2-dev libsdl-image1.2-dev libsdl-ttf2.0-dev

More are potentially needed:

    http://stackoverflow.com/questions/7652385/where-can-i-find-and-install-the-dependencies-for-pygame

The installation should then be easy.  pygame camera support is currently
disabled in python3 onwards, which is good because it won't compile anyway as
Debian 8 is missing a <linux/video.h> header.

    $ mkdir -p /opt/pygame/src
    $ cd /opt/pygame/src
    $ hg clone https://bitbucket.org/pygame/pygame
    $ cd pygame
    $ python3 setup.py install --prefix=/opt/pygame

...but that failed to run, complaining about a missing object:

    $ PYTHONPATH=/opt/pygame/lib/python3.4/site-packages ./pygame
    Traceback (most recent call last):
      File "./pygame", line 41, in <module>
        import pygame
      File "/opt/pygame/lib/python3.4/site-packages/pygame/__init__.py", line 95, in <module>
        from pygame.base import *
    ImportError: /opt/pygame/lib/python3.4/site-packages/pygame/base.cpython-34m.so: undefined symbol: PyCObject_Check

Clone the hg repo, and build from there instead!

It all works!!!

    $ sudo env PYTHONPATH=/opt/pygame/lib/python3.4/site-packages ./pygame

If you have Eurostile, make sure it is in one of:

    * /usr/share/fonts
    * /usr/local/share/fonts
    * ~/.fonts

"""

import os
import pygame
import queue
import random
import signal
import subprocess
import sys
import tempfile
import threading
import time


class DataSource():
    def has_changed(self):
        pass

    def get_data(self):
        pass


class SQLiteDataSource(DataSource):
    def __init__(db_path):
        self.db_path = db_path

    def has_changed(self):
        pass

    def get_data(self):
        pass


class MockDataSource(DataSource):
    # f(x) = ax + b
    class Model():
        def __init__(self, a, b):
            self.a = a
            self.b = b
            self.rng = random.Random(a * b)

        def f(self, x):
            y = self.a * x + self.b
            j = self.rng.random() * self.b * 0.05
            return(y + j)

    update_interval = 1

    def __init__(self):
        self.epoch = time.time()
        self.t0 = 0
        self.rng = random.Random(42)
        self.lock = threading.Lock()
        self.food_model = self.Model(50.0/60,  20.0)
        self.oven_model = self.Model( 5.0/60, 175.0)
        self.food_data = []
        self.oven_data = []

    def has_changed(self):
        t1 = time.time() - self.epoch
        dt = t1 - self.t0
        if dt < self.update_interval:
            return False
        with self.lock:
            while self.t0 < (t1 - self.update_interval):
                self.t0 += self.update_interval
                self.food_data.append((self.t0, self.food_model.f(self.t0)))
                self.oven_data.append((self.t0, self.oven_model.f(self.t0)))
        return True

    def fetch(self):
        with self.lock:
            food = self.food_data[:]
            oven = self.oven_data[:]
        return (self.epoch, food, oven)


class Plotter():
    def __init__(self, size):
        self.size = size
        self.food_table = self._tf('food', 'table')
        self.oven_table = self._tf('oven', 'table')

    def _tf(self, prefix, suffix):
        return tempfile.NamedTemporaryFile(
            prefix='bluetherm-plotter-' + prefix,
            suffix=suffix
        )

    def plot(self, epoch, food_data, oven_data):
        self._write_data(self.food_table.name, food_data)
        self._write_data(self.oven_table.name, oven_data)
        png = self._tf('plot', 'png')
        (width, height) = self.size
        command = [
            'Rscript', 'plot.R',
            epoch,
            self.food_table.name,
            self.oven_table.name,
            png.name,
            width,
            height,
        ]
        command = [str(c) for c in command]
        try:
            subprocess.check_call(command)
            return png
        except subprocess.CalledProcessError as ex:
            # The actual error will show up on STDERR
            return None

    def _write_data(self, path, data):
        f = open(path, 'w')
        f.write("time temperature\n")
        for row in data:
            f.write(' '.join([str(x) for x in row]))
            f.write("\n")
        f.close()


class Color():
    black = (0x00, 0x00, 0x00)
    gray  = (0x80, 0x80, 0x80)
    white = (0xff, 0xff, 0xff)

#
# Also available is the pygame.freetype stuff.  The kerning is better but the
# fonts don't reliably render at the same vertical position frame-after-frame
# :/
#

class WallClock(pygame.sprite.DirtySprite):
    def __init__(self, font, format='%Y.%m.%d %H:%M:%S'):
        pygame.sprite.DirtySprite.__init__(self)

        self.font = font
        self.format = format
        self.last = None

        dummy = self._text(self._clock_string())
        self.image = pygame.Surface(dummy.get_rect().size)
        self.rect = self.image.get_rect()

    def update(self):
        now = self._clock_string()
        if now == self.last:
            return
        text = self._text(now)
        self.image.fill(Color.black)
        self.image.blit(text, (0, 0))
        self.dirty = 1

    def _clock_string(self):
        return time.strftime(self.format)

    def _text(self, clock_string):
        return self.font.render(clock_string, 1, Color.gray)


class TemperatureReading(pygame.sprite.DirtySprite):
    LABEL_MARGIN_RIGHT = 7
    UNSET = -300.0

    def __init__(self, font, label):
        pygame.sprite.DirtySprite.__init__(self)

        self.font = font
        self.label = label
        self.last_reading = self.UNSET
        self.label_text = self.font.render(label, 1, Color.gray)
        self.label_width = self.label_text.get_rect().width

        dummy_value_text = self._build_value_text(999.0)
        height = font.get_linesize() # Approx. ascent + descent + 1
        width = (
            self.label_width +
            dummy_value_text.get_rect().width +
            self.LABEL_MARGIN_RIGHT
        )

        self.image = pygame.Surface((width, height))
        self.rect = self.image.get_rect()
        self.set(None)

    def set(self, t):
        if t == self.last_reading:
            return
        self.image.fill(Color.black)
        self.image.blit(self.label_text, (0, 0))
        value_text = self._build_value_text(t)
        value_rect = value_text.get_rect()
        value_rect.left = (
            self.label_width +
            self.LABEL_MARGIN_RIGHT
        )
        self.image.blit(value_text, value_rect)
        self.last_reading = t
        self.dirty = 1

    def _build_value_text(self, t):
        if t is None:
            return self.font.render('.....', 1, Color.gray)
        else:
            t_str = str(round(float(t), 1)) + "\u00B0C"
            return self.font.render(t_str, 1, Color.white)


class PlotPane(pygame.sprite.DirtySprite):
    def __init__(self, size):
        pygame.sprite.DirtySprite.__init__(self)
        self.image = pygame.Surface(size)
        self.rect = self.image.get_rect()

    def load(self, png_path):
        plot_image = pygame.image.load(png_path)
        inverse = pygame.Surface(plot_image.get_rect().size, pygame.SRCALPHA)
        inverse.fill((0xff, 0xff, 0xff, 0xff))
        inverse.blit(plot_image, (0, 0), None, pygame.BLEND_RGB_SUB)
        self.image.blit(inverse, (0, 0))
        self.dirty = 1

pygame.init()
pygame.display.init()

info = pygame.display.Info()
g_width, g_height = info.current_w, info.current_h

if sys.platform == 'darwin':
    g_width  = int(0.9 * g_width)
    g_height = int(0.9 * g_height)

g_font_size = int(g_width / 36)

size = (g_width, g_height)

pygame.mouse.set_visible(False)

clock = pygame.time.Clock()
screen = pygame.display.set_mode(size, 0, 32)

background = pygame.Surface(screen.get_size())
background = background.convert()
background.fill(Color.black)

font = pygame.font.SysFont('Eurostile', g_font_size)

wall_clock = WallClock(font)
wall_clock.rect.topleft = (10, 10)

food_temperature = TemperatureReading(font, 'food')
food_temperature.rect.top = 10
food_temperature.rect.right = g_width - 10

oven_temperature = TemperatureReading(font, 'oven')
oven_temperature.rect.top = 10
oven_temperature.rect.right = food_temperature.rect.left - 30

plot_pane = PlotPane(
    (g_width - (10 * 2),
    g_height - wall_clock.rect.height - (10 * 3))
)
plot_pane.rect.top = wall_clock.rect.bottom + 10
plot_pane.rect.left = 10

data_source = MockDataSource()
plotter = Plotter((plot_pane.rect.width, plot_pane.rect.height))

allsprites = pygame.sprite.LayeredDirty((
    wall_clock,
    food_temperature,
    oven_temperature,
    plot_pane,
))
allsprites.clear(screen, background)

class PlotWorker(threading.Thread):
    PLOTREADY = pygame.USEREVENT + 1

    def __init__(self, plotter):
        threading.Thread.__init__(self)
        self.plotter = plotter
        self.q = queue.Queue()

    def run(self):
        self.running = True
        while self.running:
            epoch = None
            while not self.q.empty():
                (epoch, food_data, oven_data) = self.q.get()
            if epoch is None:
                continue
            png_tempfile = self.plotter.plot(epoch, food_data, oven_data)
            if png_tempfile is None:
                continue
            event = pygame.event.Event(
                self.PLOTREADY,
                png_tempfile=png_tempfile,  # pass to avoid garbage collection
                png_path=png_tempfile.name,
            )
            pygame.event.post(event)

pw = PlotWorker(plotter)
pw.start()

def signal_handler(signal, frame):
    pygame.event.post(pygame.event.Event(pygame.QUIT))

signal.signal(signal.SIGINT, signal_handler)

is_run = True
while is_run:
    clock.tick(30)

    if data_source.has_changed():
        new = data_source.fetch()
        pw.q.put(new)
        (epoch, food_data, oven_data) = new
        if len(food_data) > 0:
            food_t = food_data[-1][1]
            food_temperature.set(food_t)
        if len(oven_data) > 0:
            oven_t = oven_data[-1][1]
            oven_temperature.set(oven_t)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            is_run = False
        elif event.type == PlotWorker.PLOTREADY:
            plot_pane.load(event.png_path)
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                pygame.event.post(pygame.event.Event(pygame.QUIT))

    allsprites.update()
    rects = allsprites.draw(screen)
    pygame.display.update(rects)

pw.running = False
pw.join()
pygame.quit()
sys.exit()
