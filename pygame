#!/usr/bin/env python3
"""

= OS X:

  brew install python3 hg sdl sdl_image sdl_mixer sdl_ttf portmidi
  pip3 install hg+http://bitbucket.org/pygame/pygame
  pip3 install pillow

= Debian 8:

There is no python3-pygame package, but we can build our own.  I used this
pygame:

    http://www.pygame.org/ftp/pygame-1.9.1release.tar.gz

I needed these dependencies:

    $ sudo apt-get install python3-dev libsdl1.2-dev libsdl-image1.2-dev libsdl-ttf2.0-dev

More are potentially needed:

    http://stackoverflow.com/questions/7652385/where-can-i-find-and-install-the-dependencies-for-pygame

The installation should then be easy.  pygame camera support is currently
disabled in python3 onwards, which is good because it won't compile anyway as
Debian 8 is missing a <linux/video.h> header.

    $ mkdir -p /opt/pygame/src
    $ cd /opt/pygame/src
    $ hg clone https://bitbucket.org/pygame/pygame
    $ cd pygame
    $ python3 setup.py install --prefix=/opt/pygame

...but that failed to run, complaining about a missing object:

    $ PYTHONPATH=/opt/pygame/lib/python3.4/site-packages ./pygame
    Traceback (most recent call last):
      File "./pygame", line 41, in <module>
        import pygame
      File "/opt/pygame/lib/python3.4/site-packages/pygame/__init__.py", line 95, in <module>
        from pygame.base import *
    ImportError: /opt/pygame/lib/python3.4/site-packages/pygame/base.cpython-34m.so: undefined symbol: PyCObject_Check

Clone the hg repo, and build from there instead!

It all works!!!

    $ sudo env PYTHONPATH=/opt/pygame/lib/python3.4/site-packages ./pygame

If you have Eurostile, make sure it is in one of:

    * /usr/share/fonts
    * /usr/local/share/fonts
    * ~/.fonts

"""

import optparse
import os
import pygame
import queue
import random
import signal
import sqlite3
import subprocess
import sys
import tempfile
import threading
import time


class DataSource():
    def time(self):
        pass

    def fetch_new(self):
        pass


class SQLiteDataSource(DataSource):
    def __init__(self, db_path):
        self.db_path = db_path
        self.con = sqlite3.connect(db_path)
        yesterday = self.time() - 86400
        self.food_mtime = yesterday
        self.oven_mtime = yesterday

    def time(self):
        return time.time()

    def fetch_new(self):
        now = self.time()
        new_food = self._read(2, self.food_mtime, now)
        if len(new_food) > 0:
            self.food_mtime = new_food[-1][0]
        new_oven = self._read(1, self.oven_mtime, now)
        if len(new_oven) > 0:
            self.oven_mtime = new_oven[-1][0]
        return(now, new_food, new_oven)

    def _read(self, sensor, time_from, time_to):
        template = (
            'SELECT epoch, mC FROM sensor_{} '
            'WHERE epoch > {} AND epoch <= {} '
            'AND mC > -300000 '
            'ORDER BY epoch ASC'
        )
        sql = template.format(sensor, time_from, time_to)
        cur = self.con.cursor()
        cur.execute(sql)
        res = cur.fetchall()
        cur.close()
        return res


class MockDataSource(DataSource):
    UPDATE_INTERVAL = 10
    SPEED_UP = 60

    def __init__(self):
        self.epoch = time.time()
        self.t0 = self.epoch

    def time(self):
        actual_duration = time.time() - self.epoch
        return(self.epoch + (self.SPEED_UP * actual_duration))

    def fetch_new(self):
        t1 = self.time()
        dt = t1 - self.t0
        if dt < self.UPDATE_INTERVAL:
            return None
        food, oven = [], []
        while self.t0 < (t1 - self.UPDATE_INTERVAL):
            self.t0 += self.UPDATE_INTERVAL
            oven_t = 175.0
            food_t = 20 + (50/3600 * (self.t0 - self.epoch))
            food.append((self.t0, food_t))
            oven.append((self.t0, oven_t))
        return(self.t0, food, oven)


class DataBuffer(DataSource):
    MAX_GAP = 3600

    def __init__(self, data_source):
        self.data_source = data_source
        self.food = []
        self.oven = []

    def fetch(self):
        new = self.data_source.fetch_new()
        if new is None: 
            return None
        (now, food, oven) = new
        self._add(self.food, food)
        self._add(self.oven, oven)
        return(now, self.food, self.oven)

    def _add(self, ar0, ar1):
        for pair1 in ar1:
            if len(ar0) > 0:
                time0 = ar0[-1][0]
                time1 = pair1[0]
                if time1 - time0 > self.MAX_GAP:
                    ar0.clear()
            ar0.append(pair1)


class Plotter():
    def __init__(self, size):
        self.size = size
        self.food_table = self._tf('food', 'table')
        self.oven_table = self._tf('oven', 'table')

    def _tf(self, prefix, suffix):
        return tempfile.NamedTemporaryFile(
            prefix='bluetherm-plotter-' + prefix,
            suffix=suffix
        )

    def plot(self, now, food_data, oven_data):
        self._write_data(self.food_table.name, food_data)
        self._write_data(self.oven_table.name, oven_data)
        png = self._tf('plot', 'png')
        (width, height) = self.size
        command = [
            'Rscript', 'plot.R',
            now,
            self.food_table.name,
            self.oven_table.name,
            png.name,
            width,
            height,
        ]
        command = [str(c) for c in command]
        try:
            subprocess.check_call(command)
            return png
        except subprocess.CalledProcessError as ex:
            # The actual error will show up on STDERR
            return None

    def _write_data(self, path, data):
        f = open(path, 'w')
        f.write("time temperature\n")
        for row in data:
            f.write(' '.join([str(x) for x in row]))
            f.write("\n")
        f.close()


class Color():
    black = (0x00, 0x00, 0x00)
    gray  = (0x80, 0x80, 0x80)
    white = (0xff, 0xff, 0xff)

class WallClock(pygame.sprite.DirtySprite):
    def __init__(self, time_fn, font, format='%Y.%m.%d %H:%M:%S'):
        pygame.sprite.DirtySprite.__init__(self)

        self.time_fn = time_fn
        self.font = font
        self.format = format
        self.last = None

        dummy = self._text(time.strftime(format))
        self.image = pygame.Surface(dummy.get_rect().size)
        self.rect = self.image.get_rect()

    def update(self):
        now = self.time_fn()
        if now == self.last:
            return
        self.last = now
        text = self._text(time.strftime(self.format, time.localtime(now)))
        self.image.fill(Color.black)
        self.image.blit(text, (0, 0))
        self.dirty = 1

    def _text(self, clock_string):
        return self.font.render(clock_string, 1, Color.gray)


class TemperatureReading(pygame.sprite.DirtySprite):
    LABEL_MARGIN_RIGHT = 12
    UNSET = -300.0
    RATE = 20

    def __init__(self, font, label):
        pygame.sprite.DirtySprite.__init__(self)

        self.font = font
        self.label = label
        self.label_text = self.font.render(label, 1, Color.gray)
        self.label_width = self.label_text.get_rect().width

        self.t0 = None
        self.t1 = None
        self.pp = 100
        self.is_first = True

        dummy_value_text = self._build_value_text(999.0, Color.white)
        height = font.get_linesize() # Approx. ascent + descent + 1
        width = (
            self.label_width +
            dummy_value_text.get_rect().width +
            self.LABEL_MARGIN_RIGHT
        )

        self.image = pygame.Surface((width, height))
        self.rect = self.image.get_rect()
        self.set(None)

    def set(self, t):
        if self.t1 != t:
            self.t0 = self.t1
            self.t1 = t
            self.pp = 0

    def update(self):
        if self.is_first:
            self.is_first = False
        elif self.pp == 100:
            return

        self.image.fill(Color.black)
        self.image.blit(self.label_text, (0, 0))

        self.pp = min(100, self.pp + self.RATE)
        if self.pp < 50:
            v = 100 - (2 * self.pp)
            t = self.t0
        else:
            v = (2 * self.pp) - 100
            t = self.t1
        color = [0xff * (v/100.0) for _ in range(3)]
        value_text = self._build_value_text(t, color)
        value_rect = value_text.get_rect()
        value_rect.left = self.label_width + self.LABEL_MARGIN_RIGHT
        self.image.blit(value_text, value_rect)
        self.dirty = 1

    def _build_value_text(self, t, color):
        if t is None:
            return self.font.render('.....', 1, color)
        else:
            t_str = str(round(float(t), 1)) + "\u00B0C"
            return self.font.render(t_str, 1, color)


class CountdownBar(pygame.sprite.DirtySprite):
    TIMEOUT = 10000 # ms

    def __init__(self, size):
        pygame.sprite.DirtySprite.__init__(self)
        self.image = pygame.Surface(size)
        self.rect = self.image.get_rect()
        self.reset()

    def reset(self):
        self.image.fill(Color.gray)
        self.start_ms = pygame.time.get_ticks()
        self.last_dur_ms = None

    def update(self):
        dur_ms = pygame.time.get_ticks() - self.start_ms
        dur_ms = 100 * (dur_ms // 100)
        if dur_ms == self.last_dur_ms:
            return
        self.last_dur_ms = dur_ms
        if dur_ms < self.TIMEOUT:
            w = self.rect.width
            bar = pygame.Rect(
                w - (w * dur_ms // self.TIMEOUT),
                0,
                w,
                self.rect.height
            )
            self.image.fill(Color.black, bar)
            self.dirty = 1


class PlotPane(pygame.sprite.DirtySprite):
    def __init__(self, size):
        pygame.sprite.DirtySprite.__init__(self)
        self.image = pygame.Surface(size)
        self.rect = self.image.get_rect()

    def load(self, png_path):
        plot_image = pygame.image.load(png_path)
        self.image.blit(plot_image, (0, 0))
        self.dirty = 1


parser = optparse.OptionParser()
parser.add_option('--test')
parser.add_option(
    '--sqlite-path',
    type='string',
    default='/var/lib/bluethermd/sqlite',
    dest='sqlite_path',
)
(options, args) = parser.parse_args()

if options.test:
    data_source = MockDataSource()
else:
    data_source = SQLiteDataSource(options.sqlite_path)

pygame.init()
pygame.display.init()

info = pygame.display.Info()
g_width, g_height = info.current_w, info.current_h

if sys.platform == 'darwin':
    scale = 0.95
    g_width  = int(scale * g_width)
    g_height = int(scale * g_height)

g_font_size = int(g_width / 36)

size = (g_width, g_height)

data_buffer = DataBuffer(data_source)

pygame.mouse.set_visible(False)

clock = pygame.time.Clock()
screen = pygame.display.set_mode(size, 0, 32)

background = pygame.Surface(screen.get_size())
background = background.convert()
background.fill(Color.black)

# The FreeType parts of pygame have better kerning, but have a bug whereby the
# baseline has jitter.
font = pygame.font.SysFont('Eurostile', g_font_size)

wall_clock = WallClock(data_source.time, font)
wall_clock.rect.topleft = (10, 10)

food_temperature = TemperatureReading(font, 'food')
food_temperature.rect.top = 10
food_temperature.rect.right = g_width - 10

oven_temperature = TemperatureReading(font, 'oven')
oven_temperature.rect.top = 10
oven_temperature.rect.right = food_temperature.rect.left - 50

countdown_bar = CountdownBar((g_width, 3))
countdown_bar.rect.topleft = (0, wall_clock.rect.bottom + 10)

plot_pane = PlotPane((
    g_width - (10 * 2),
    g_height - countdown_bar.rect.bottom - 20
))
plot_pane.rect.top = countdown_bar.rect.bottom + 10
plot_pane.rect.left = 10

plotter = Plotter((plot_pane.rect.width, plot_pane.rect.height))

allsprites = pygame.sprite.LayeredDirty((
    wall_clock,
    food_temperature,
    oven_temperature,
    countdown_bar,
    plot_pane,
))
allsprites.clear(screen, background)

class PlotWorker(threading.Thread):
    PLOTREADY = pygame.USEREVENT + 1

    def __init__(self, plotter):
        threading.Thread.__init__(self)
        self.plotter = plotter
        self.q = queue.Queue()

    def run(self):
        self.running = True
        while self.running:
            now = None
            while not self.q.empty():
                (now, food_data, oven_data) = self.q.get()
            if now is None:
                continue
            png_tempfile = self.plotter.plot(now, food_data, oven_data)
            if png_tempfile is None:
                continue
            event = pygame.event.Event(
                self.PLOTREADY,
                png_tempfile=png_tempfile,  # pass to avoid garbage collection
                png_path=png_tempfile.name,
                now=now,
                food_data=food_data,
                oven_data=oven_data,
            )
            pygame.event.post(event)

pw = PlotWorker(plotter)
pw.start()

def signal_handler(signal, frame):
    pygame.event.post(pygame.event.Event(pygame.QUIT))

signal.signal(signal.SIGINT, signal_handler)

is_run = True
while is_run:
    clock.tick(30)

    new = data_buffer.fetch()
    if new:
        # Defer updating food_temperature and oven_temperature until the
        # plot_pane is redrawn -- an expensive operation that makes makes
        # animations jerky!
        pw.q.put(new)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            is_run = False
        elif event.type == PlotWorker.PLOTREADY:
            plot_pane.load(event.png_path)
            food_t = event.food_data[-1][1]
            oven_t = event.oven_data[-1][1]
            food_temperature.set(food_t)
            oven_temperature.set(oven_t)
            countdown_bar.reset()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                pygame.event.post(pygame.event.Event(pygame.QUIT))

    allsprites.update()
    rects = allsprites.draw(screen)
    pygame.display.update(rects)

pw.running = False
pw.join()
pygame.quit()
sys.exit()
